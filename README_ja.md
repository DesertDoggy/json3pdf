# json3pdf
## 注意！: これらのスクリプトは現在アルファ段階です。また、私の初めてのスクリプトなので、予期しない重大なエラーや、むしろ多くのバグが予想されます。念のため、元の画像ファイルを保持しておくことをお勧めします。
## 免責事項: 私はプロの開発者ではありません。バグ報告は感謝しますが、修正は保証されず、返信が遅くなることがあります。(英語先に書いて翻訳かけて校正してるからところどころ日本語おかしいけど許して。)

- [English](./README.md)
- [日本語](./README_ja.md)

## 説明
スキャンした本をMicrosoft Azure Document Intelligence*1によるOCRかけてクリアテキストを追加、検索可能にするスクリプト群。
最初はOCRだけするつもりが、スキャンからの変換バッチ処理までなぜか追加。

img2j2kは、以下の理由でpng、tif、bmpファイルを無損失jpeg2000に変換するために書いてみた。
1.私のスキャナーはJpeg2000の無損失バージョンに変換できません。
2.他の無損失形式はファイルサイズでかすぎかPDF非対応です。
3."名前は言えないPDFソフトウェア"が"自環境では(強調)"遅いうえにクラッシュしすぎ。
画像変換でロスレスと最適化の両方を行う理由は、1. Document Intelligence*1は最大500MBまで。 2. OCR目的のためには高dpiが推奨されるから。
j2k2pdfはその目的のために画像をPDFにバッチ変換するために書いてみた。ほとんどimg2pdfの機能でバッチ部分だけ追加の上に機能制限かけてる。

なんで、劣化やファイルサイズを気にしない、ロスレスJpeg 2000としてスキャンできる環境がある、または"名前は言えないPDFソフトウェア"が自環境で問題なく使用可能な人などはOCR前スクリプトはいらないと思う。またはimg2pdf使った方がいいよ。
また、従来型のOCRや他のAI OCRで満足している人は（いるのか？AIはともかく）、OCR後スクリプトも必要ないと思われ。

## 依存関係

Python3環境
openjpeg (openjp2.dll)。ファイルパスを環境変数に要追加。*2,*3

必要なpip install (スクリプトごと)
img2j2k: PIL (pillow), numpy, glymur, lxml, colorama
j2k2pdf: img2pdf, PIL (pillow), PyPDF2, colorama
pdf3json: dotenv,azure.core.credentials,azure.ai.documentintelligence
json3pdf: reportlab
mergejs: PyPDF2

## 使い方 (スクリプトのCLIオプションは下のセクションで説明します)
### 準備
1. PDFに変換する画像を準備します。
これらのスクリプトは、自分のアーカイブ目的でスキャンした書籍にOCRをかけていくために書いたので。ファイルからDPIが読み取れない場合、デフォルトでは600 dpiになります。通常のデフォルトの72 dpiや96 dpiではないので注意。また、jpeg 2000に変換すると、jpeg 2000の形式によりファイルからdpi情報が失われる可能性があります。dpi情報は一応xmlに書き込むコードを実装したけど、j2kの仕様のせいか間違ってるだけかわからんけど読取は微妙なので現時点ではスキャンdpiが600以外の場合、各スクリプトからコマンドラインでdpi値を指定する必要があるかも。
2. ./OriginalImagesのサブフォルダに画像を配置します。現時点では、スクリプトは直下のサブフォルダのみをスキャンする仕様。
3. PDFページはファイル名のアルファベット順に挿入されます。予定されているスクリプトの互換性のため、ファイルとサブフォルダを特定の形式にリネームすることを推奨しますが、現時点ではアルファベット順であれば動作するはずです。(て書いたけどtotal_pとか変数入れてるのでバグるかも)
        ./OriginalImages/本のタイトル/本のタイトル_cover,T本のタイトル_p0000,本のタイトル_p0001,......,本のタイトル_z0001,本のタイトル_z0002...)
        _cover: 本の表紙, _p0000:内表紙または索引, _p0001～:ページ, _z0001～: 同梱の図表など
4. openjp2.dllのパスをシステムに追加して、glymurがアクセスできるようにします。*2,*3

### img2j2k.py (画像ファイルをPDF互換のJpeg2000に変換)
1. スキャンした画像を./OriginalImagesのサブディレクトリに配置します。(./OriginalImages/Title/img.png...etc)
   !!画像ファイル名は次のステップ(j2k2pd)でファイル名の末尾でページカウントなどの処理が入っているので画像ファイルを変換する前のここで必要な形式にリネームすることを推奨!!
2. スクリプトを実行します。画像はアーカイブ目的のロスレスJpeg2000に変換され、OCRに使用するための最適化されたJpeg2000に変換されます。
3. 変換された画像は出力フォルダに配置されます。(./TEMP/lossless,./TEMP/optimized)
   
   デフォルトでは、同じ画像がアーカイブ目的の無損失Jpeg2000と、Document Intelligence *1でOCRを実行するための劣化...もとい最適化されたJpeg2000の両方に変換されます。
   最適化はピクセル解像度をリサイズしないことに注意してください。なぜなら、OCRには高dpiが推奨されるからです。
   オプションでdpiが指定されていない場合、スクリプトは画像ファイルからdpiを読み取り、72または50*n≧150に丸めます。これは、スキャナーがそれを（おそらく）浮動小数点で設定するためです。ファイルから読み取ることができない場合、デフォルトでは600になります。

### j2k2pdf.py (PDF対応の画像ファイルをPDFに無損失で挿入)
(入力フォルダにPDF互換の画像を配置します。入力フォルダはimg2j2k.pyの出力フォルダと同じです。存在しない場合は作成を。)
1. スクリプトを実行します。PDFファイルは自動的に出力フォルダに作成されます。各サブディレクトリは独立したPDFファイルとして出力されます。
   出力フォルダは、ロスレスのアーカイブ用PDFは./OriginalPDF、OCR用の最適化PDFは./OptimizedPDFです。

  !!画像ファイル名はフォーマットどおりじゃないとバグるかも。このステップを実行する前に、上記で述べた必要な形式にリネームしてください。これは、スキャンした画像をページ順に組み合わせるためです。
  dpiは自動で読み取って上記のように設定されるけど、現時点ではjpeg2000のdpiはトリッキーで上手く適用できないみたいなんで、600でない場合はオプションを設定することをお勧めします。
  ページサイズもオプションで設定されていない場合、解像度とdpiからページサイズを自動的に推定します。現時点では、互換性のあるページサイズの形式はA3からA6、B4からB7、タブロイド、ブランケットです。カスタムサイズは計画されていますが、まだ実装されていません。

### pdf3json (OCR)
1. diAPI.env.template.txtを使用して、Docunent Intelligence*1 APIのOCRを使用するための認証ファイル(.env)を作成します。
   Document Intelligence*1 Studio Readのみがサポートされています。他のモードでも動作するかもしれませんが、実装する予定はありません。
   Document Intelligence*1の最大ファイルサイズ制限は500MBですが、大きなファイルは頻繁に失敗するようです。この問題に遭遇した場合は、PDFファイルを複数のファイルに分割してみてください。これで問題が解決することがあります。

### OCR alternative
1. 最適化されたPDFをMicrosoft Document Intelligence *1 Studio Readにアップロードします。
2. 分析を実行し、作成されたjsonファイルをダウンロードします。
3. jsonファイルを./DIjsonフォルダに配置します。jsonファイルの名前を絶対に変更しない！.pdf.jsonの.pdfを削除するのもダメ！現時点では、それをPDFのOCRファイルとして検出するために必要です。また、ロスレスと最適化PDFのファイル名前を同じに保つこと。
   Document Intelligence*1 Studio Readのみがサポートされています。他のモードでも動作するかもしれませんが、実装する予定はありません。
   Document Intelligence*1の最大ファイルサイズ制限は500MBですが、大きなファイルは頻繁に失敗するようです。この問題に遭遇した場合は、PDFファイルを複数のファイルに分割してみてください。これで問題が解決することがあります。

### json3pdf.py (最終ファイルの調整用に黒文字PDFファイルを作成)

1. スクリプトを実行します。これにより、jsonから出力フォルダ(./OCRtextPDF)に_TextOnly PDFファイルが出力され、元のレイアウトとアバウトに同じになります。

フォントサイズをオプションで調整する必要があるかもしれません。また、.data/fontsに配置し、オプションを設定することで他のttfフォントも使用できます。デフォルトではNotoSansJP-Regularがバンドルされています。*4

### mergejs.py (調整用の最適化されたPDFファイルと黒文字PDFファイルをマージ)

1. スクリプトを実行します。これにより、_TextOnly PDFからマージされたテキストレイヤーを持つ最適化されたPDFと一緒に_merged PDFファイルが出力されます。
2. レイアウトがずれてる場合は、オプションで調整し、正しいまで再度マージします。

レイアウト調整は、オプションによりポイント単位（1インチ = 72pt、1cm = 28.3465pt）で設定されます。
jpeg2000から作成されたPDFファイルなど、dpiを考慮せずに作成された一部のPDFファイルとか50インチとか異常なページサイズ(テレビかよｗ)になってフォントやレイアウトが壊れたりどっか行っちゃったりするんで、ページサイズを推定、最大許容ページサイズを10％マージンで超える場合、ポイントでレイアウトを調整する際にdpiも併せて指定で変換係数がかかってちゃんと調整できると思うけどできなかったら教えて。
現時点では、縦書きテキストレイアウトは完全対応はしてない。透明テキスト用なら配置自体は一致するので問題なし。可視テキストにするならレイアウトオプションでwordを指定すると縦書きも大丈夫そうだけど、代わりに１文字単位になるので検索不可になる。

### json3pdf (検索可能なテキストレイヤー用にクリアテキストPDFファイルを作成)

1. --clear,-cをつけてスクリプトを実行します。これにより、_ClearText PDFファイルが出力フォルダ(./OCRclearPDF)に出力されます。
   １回目で調整した設定をオプションで指定してね。

### mergejs (最終出力用に元のPDFファイルとクリアテキストPDFファイルをマージ)

1. --clear,-cをつけてスクリプトを実行します。これにより、_OCR検索可能なクリアテキストPDFファイルが出力フォルダ(./OCRfinalPDF)に出力されます。
   １回目で調整した設定をオプションで指定してね

*1. Microsoft、Azure、Document Intelligenceは、Microsoftグループの商標です。
*2 openjpegはBSDライセンスでライセンスされています。
*3 dllはパッケージ(./data/dll)に含まれています。公式サイトやリポジトリから最新バージョンをダウンロードすることもできます。
*4 Open Font License

## オプション
### 共通オプション
--log-level, -log, -debug: ログレベルを設定します。: --log-level DEBUG,VERBOSE,INFO,WARNING:デフォルトはINFO
### img2j2k
--dpi: 出力画像メタデータのdpiを設定します。: --dpi 整数: 正（--dpi 300）画像ファイルから読み取られない場合にdpiを設定します。負（--dpi -300）強制的にdpiを設定します。0（--dpi 0）は、一般的なdpi値や整数への丸めなしでファイルから読み取ったdpiを使用します。: 不明なdpiのデフォルトは600です。
--quick, -q: ビットパーフェクトロスレス変換のチェックをスキップします。
--check: ビットパーフェクトロスレス変換のチェックのタイプを設定します。:--check slow, 最終出力ファイルをpillowとnumpyで開いてチェック。 --check fast, 一時ファイル（出力ファイルが最終ファイル名にリネームされる前の変換出力ファイル）をglymurで開き、元のファイルと比較します。:デフォルトは --check slowです。
      これは、glymur（またはopenjpeg）と互換性のない日本語（たぶん中韓その他２バイト言語も）を含むファイルを変換するためのワークアラウンドです。
--temp,-t: 一時ファイルの作業フォルダを設定します。: これは実験的です。スクリプトが一時ファイルを最終出力としてリネームするため、デフォルトのままにするか、出力フォルダと同じドライブに設定することを推奨します。
--lossless,-l: ロスレス変換のみを実行します
--optimize,-o: 最適化変換のみを実行します。ロスレスチェックはスキップされます。

### j2k2pdf
--simple-check,-s: PDFが正常に作成されたかどうかを簡単にチェックします。デフォルトは1、0=オフ）

### json3pdf
--pages,-p: PDFを指定したページ数に分割します。デフォルトではPDFが300ページを超える場合に自動で分割します。
--divide,-d: PDFを指定した数の部分に分割します。デフォルトは1
--no-divide: 300ページのリミットを無視し、PDF全体を処理しようとします
--attempts: 最大試行回数。デフォルトは3
--no-delete: マージが失敗した場合に備えて、分割されたPDFファイルとマージされていないjsonファイルを保持します。

### pdf3json
--size,-s: フォントサイズを調整します。デフォルトは100 (%)
--font-threshold,-t:--individual:要素をまたいだ場合でも閾値を超えなければフォントサイズを一定に保ちます。単位%。--individualは要素ごとに個別にjson内のデータから計算して決定します。（現時点ではデフォルトで閾値なし）
--hfont,-hf:横書きフォントを設定します。デフォルトはNotoSansJP-Regular.ttf *4
--vfont,-vf:縦書きフォントを設定します。デフォルトはNotoSansJP-Regular.ttf *4 現状縦書き部分は英語と同じに横向きになっちゃうので無意味。
--dpi,-d: デフォルトは600
--page,-p: PDFのページサイズを設定します。デフォルトはA5（JSONからページサイズを読み取れない場合）
--layout:テキストを描画する単位。word、line、またはparagraph。デフォルトはline（検索可能なテキストPDFには一定の文節単位で検索できるようにlineが推奨されます。何らかの理由で縦書きの可視テキストが必要な場合（例：日本語のレイアウトを可視的に維持する場合など。現状lineだと縦書きは英語同様に横向きになってしまうので。検索用clear textにするだけなら描画範囲自体一致はするのでlineの方を推奨）はwordが推奨されます。現時点ではparagraphは使い物にならない）。
#--area,-ar:段落内の行を数えるためのエリア閾値。実験的paragraph用機能！デフォルトは80
#--similarity,-st:段落に行を追加するための類似性閾値を設定します。実験的paragraph用機能！デフォルトは0.1
#--adjust, -ad:行と段落のレイアウトを調整します。実験的な機能！デフォルトはFalse
#--coordinate, -ct:行と段落の座標調整のための座標閾値を設定します。実験的な機能です！デフォルトは80 #おそらく必要なし。最初はレイアウトがずれたりしたんで、tesseract併用で位置調整しようと思ったけど、時間かかりすぎる上にコード修正でほぼずれなくなったので削除するかも。
--clear,-c:クリアテキストPDFを出力します
--search,-se,レイアウト "line" のメインテキスト方向検出のための検索ページ制限と無視文字数。デフォルト:(50,2)